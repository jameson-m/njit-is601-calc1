{% extends "base.html" %}
{% block content %}
    <div>
        
        <main class="container">
            <div>
                <div class="top-banner">
                    <h1>Separation of Concerns</h1>
                </div>
            </div>
            <p>For a working demo application showing the separation of concerns principle, <a href="https://github.com/jameson-m/njit-is601-calc1/tree/separation_of_concerns">click here</a>.</p>
            <p>Separation of concerns is one of the key principles of software development. The general idea is that code for different ideas or concerns in an app should be kept separate. This allows for an application’s code to be much more modular and easier to maintain. If one feature has a bug that breaks its functionality completely, this does not necessarily break other areas of an application. It also allows for easier testing since it is kept separate from other parts of the app. </p>
            <p>Additionally, making code more modular allows for applications to split up functionality behind different pricing tiers or permissions. It also makes it easier to add functionality that enables third-party developers to create plug-ins for an application. Once you understand this principle, it actually becomes quite natural to divide up areas of an application instead of grouping them together.</p>

            <h2>Example: Calculator History</h2>
            <p>Let’s take a look at an example. In our calculator application we want to have the calculator keep track of its calculations history. When we initially write the application we might include the history as part of the Calculator class. However, as the application continues to grow it becomes more obvious that the calculations history should in reality be its own class. This allows for the calculations history implementation to change in the future and not impact the Calculator class. For example, let’s say that initially the history is stored in memory. Perhaps down the road we wish to store the calculations history in a database. If we have the history and Calculator class combined into one class, this would require a complete rewrite of a significant portion of the Calculator class. If instead the Calculator and calculations history classes were kept separate, the implementation of the history could change but the Calculator class would have no idea of the changes—the methods would still appear to be exactly the same as they were initially.</p>
            <p>Here’s what this separation of concerns would look like in actual code. First, we have the Calculator class:</p>
            <pre>
                <code class="language-py">
"""
Class representing a calculator.
"""
from calc.calculations.addition import Addition
from calc.calculations.division import Division
from calc.calculations.multiplication import Multiplication
from calc.calculations.subtraction import Subtraction
from calc.history.calculations import Calculations

class Calculator:
    """Calculator class"""
    @staticmethod
    def add(*args):
        """
        Adds two numbers together.

        Args:
            value_a (int): First value
            value_b (int): Second value to be added to first

        Returns:
            Calculation: The created addition calculation object
        """
        addition = Addition(args)
        Calculations.add_calculation_to_history(addition)
        return Calculations.get_last_calculation()

    @staticmethod
    def subtract(*args):
        """
        Subtracts one number from another.

        Args:
            value_a (int): First value
            value_b (int): Second value subtracted from first

        Returns:
            Calculation: The created subtraction calculation object
        """
        subtraction = Subtraction(args)
        Calculations.add_calculation_to_history(subtraction)
        return Calculations.get_last_calculation()

    @staticmethod
    def multiply(*args):
        """
        Multiplies two numbers together.

        Args:
            value_a (int): First value
            value_b (int): Second value to be multiplied on the second

        Returns:
            Calculation: The created multiplication calculation object
        """
        multiplication = Multiplication(args)
        Calculations.add_calculation_to_history(multiplication)
        return Calculations.get_last_calculation()

    @staticmethod
    def divide(*args):
        """
        Divides two numbers together.
        If dividing by zero the result is 0.

        Args:
            value_a (int): Numerator
            value_b (int): Divisor

        Returns:
            float: Result of division of two given numbers
        """
        division = Division(args)
        Calculations.add_calculation_to_history(division)
        return Calculations.get_last_calculation()
                    
                </code>
            </pre>
            <p>Notice that the Calculator class only contains methods for performing actual calculations. Within those calculation methods, calculations history methods are called to add each new calculation to the history. If we changed the history implementation in the future, the method calls here in this class would stay exactly the same. Despite a complete rewrite of how the history works, the Calculator class does not need to know about any of it, and so the method calls remain the same.</p>
            <p>Next, let’s take a look at the calculations history class:</p>
            <pre>
                <code class="language-py">
from calc.calculations.addition import Addition
from calc.calculations.subtraction import Subtraction
from calc.calculations.multiplication import Multiplication
from calc.calculations.division import Division

"""Calculation history class"""
class Calculations:
    """Calculation history class"""
    history = []

    @staticmethod
    def get_history():
        """Get full calculator history.

        Returns:
            list: List of Calculation objects
        """
        return Calculations.history

    @staticmethod
    def get_last_calculation():
        """Get the last Calculation object in history (most recent).

        Returns:
            Calculation: Most recent Calculation
        """
        return Calculations.history[-1]

    @staticmethod
    def get_first_calculation():
        """Get the first Calculation object in history.

        Returns:
            Calculation: First Calculation performed
        """
        return Calculations.history[0]

    @staticmethod
    def add_calculation_to_history(calculation):
        """Add a Calculation object to the calculator's history.

        Args:
            calculation (Calculation): Calculation object to add to history

        Returns:
            bool: Whether or not adding to history was success
        """
        Calculations.history.append(calculation)
        return True
    
    @staticmethod
    def add_addition_calculation(values):
        """Add an addition calculation to the calculator's history.

        Args:
            values (tuple): Values to be added together.
        
        Returns:
            bool: Whether or not calculation was added to history.
        """
        Calculations.add_calculation_to_history(Addition.create(values))
        return True
    
    @staticmethod
    def add_subtraction_calculation(values):
        """Add a subtraction calculation to the calculator's history.

        Args:
            values (tuple): Values to be subtracted together.
        
        Returns:
            bool: Whether or not calculation was added to history.
        """
        Calculations.add_calculation_to_history(Subtraction.create(values))
        return True
    
    @staticmethod
    def add_multiplication_calculation(values):
        """Add a multiplication calculation to the calculator's history.

        Args:
            values (tuple): Values to be multiplied together.
        
        Returns:
            bool: Whether or not calculation was added to history.
        """
        Calculations.add_calculation_to_history(Multiplication.create(values))
        return True
    
    @staticmethod
    def add_division_calculation(values):
        """Add a division calculation to the calculator's history.

        Args:
            values (tuple): Values to be divided together.
        
        Returns:
            bool: Whether or not calculation was added to history.
        """
        Calculations.add_calculation_to_history(Division.create(values))
        return True

    @staticmethod
    def get_last_calculation_result():
        """Get the last Calculation object's result.

        Returns:
            int: Most recent Calculation's result
        """
        last_index = len(Calculations.history) - 1
        return Calculations.history[last_index].get_result()

    @staticmethod
    def clear_history():
        """Clears the calculator's history.

        Returns:
            bool: If calculator's history was successfully cleared
        """
        Calculations.history.clear()
        return True

    @staticmethod
    def count_history():
        """Counts the number of items in the calculator's history.

        Returns:
            int: Number of items in calculator's history
        """
        return len(Calculations.history)
                    
                </code>
            </pre>
            <p>Notice that this code is storing the calculations history directly in memory. However, keeping these methods separate will allow for more maintainable code when implementation changes inevitably happen in the future. The Calculator and any other class that needs access to the history can call these methods to interact with it. By keeping the history class separate we’ve successfully abstracted away the implementation but given the programmer full functionality through method calls. Regardless of any future changes to its implementation, tests on the Calculator class can remain unchanged. This dramatically improves code maintainability.</p>
        </main>
    </div>
{% endblock %}    
